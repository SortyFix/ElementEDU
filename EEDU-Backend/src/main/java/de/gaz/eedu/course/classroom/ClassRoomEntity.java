package de.gaz.eedu.course.classroom;

import com.fasterxml.jackson.annotation.JsonBackReference;
import de.gaz.eedu.course.CourseEntity;
import de.gaz.eedu.course.classroom.model.ClassRoomModel;
import de.gaz.eedu.entity.model.EntityModelRelation;
import de.gaz.eedu.user.AccountType;
import de.gaz.eedu.user.UserEntity;
import de.gaz.eedu.user.model.ReducedUserModel;
import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Unmodifiable;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Represents a classroom entity in the database.
 *
 * @author ivo
 * @see EntityModelRelation
 * @see ClassRoomModel
 */
@Entity
@Getter
@Setter
@NoArgsConstructor
@Table(name = "class_room_entity")
public class ClassRoomEntity implements EntityModelRelation<String, ClassRoomModel>
{
    @Id @Setter(AccessLevel.NONE) private String id;

    @OneToMany(mappedBy = "classRoom") @JsonBackReference @Getter(AccessLevel.PRIVATE) private final Set<UserEntity> users = new HashSet<>();
    @OneToMany(mappedBy = "classRoom") @JsonBackReference private final Set<CourseEntity> courses = new HashSet<>();

    public ClassRoomEntity(@NotNull String id, @NotNull Collection<CourseEntity> courses, @NotNull Collection<UserEntity> users)
    {
        this.id = id;
        this.courses.addAll(courses);
        this.users.addAll(users);
    }

    @Override public @NotNull ClassRoomModel toModel()
    {
        return new ClassRoomModel(
                getId(),
                getStudents().stream().map(UserEntity::toReducedModel).toArray(ReducedUserModel[]::new),
                getTutor().map(UserEntity::toReducedModel).orElse(null)
        );
    }

    /**
     * Retrieves the tutor for the current classroom.
     * <p>
     * This method returns an {@link Optional} containing the tutor for the classroom if one exists.
     *
     * @return an {@link Optional} containing the tutor for the classroom if one exists.
     */
    public @NotNull Optional<UserEntity> getTutor()
    {
        return getUsers().stream().filter(teacherPredicate(true)).findFirst();
    }

    /**
     * Retrieves an unmodifiable set of students for the current classroom.
     * <p>
     * This method returns an unmodifiable {@link Set} containing all the students associated with the classroom.
     *
     * @return an unmodifiable {@link Set} containing all the students associated with the classroom.
     */
    public @NotNull @Unmodifiable Set<UserEntity> getStudents()
    {
        return users.stream().filter(teacherPredicate(false)).collect(Collectors.toUnmodifiableSet());
    }

    @Override public boolean deleteManagedRelations()
    {
        this.users.clear();
        this.courses.clear();
        return true;
    }

    /**
     * Generates a {@code Predicate<UserEntity>} based on the specified role condition.
     * <p>
     * This method creates a Predicate<UserEntity> based on the specified role condition (tutor or not).
     * The generated predicate can be used to filter UserEntity objects based on their role.
     *
     * @param teacher true if the generated predicate should check for the "tutor" role, false otherwise.
     * @return a Predicate<UserEntity> based on the specified role condition.
     */
    @Contract(pure = true, value = "_ -> new") private @NotNull Predicate<UserEntity> teacherPredicate(boolean teacher)
    {
        return current -> (teacher == current.getAccountType().equals(AccountType.TEACHER));
    }

    @Contract(pure = true, value = "-> new")
    @Override public String toString()
    { // Automatically generated by IntelliJ
        return "ClassRoomEntity{" +
                "id='" + id + '\'' +
                '}';
    }

    @Override public boolean equals(Object o)
    { // Automatically generated by IntelliJ
        if (this == o)
        {
            return true;
        }
        if (o == null || getClass() != o.getClass())
        {
            return false;
        }
        ClassRoomEntity that = (ClassRoomEntity) o;
        return Objects.equals(getId(), that.getId());
    }

    @Override public int hashCode()
    { // Automatically generated by IntelliJ
        return Objects.hashCode(getId());
    }
}
